# -*- coding: utf-8 -*-
"""
This module provides a tool to generate a Sitemap of a Flask application that uses SQLAlchemy

Basic example:

    from sitemap_ext import Sitemap

    app = Flask(__name__)
    sitemap = Sitemap(app, 'https://mysite.com')
    sitemap.config.IGNORED.extend(['/edit', '/upload'])
    sitemap.config.FOLDER = ('..', 'static',)
    sitemap.add_rule('/blog', Post, lastmod='created')
    sitemap.add_rule('/blog/tag', Tag, priority=0.4)
    app.add_url_rule('/sitemap.xml', endpoint='sitemap', view_func=sitemap.view)

also you can set configurations from your class:

    class Config:
        FOLDER = ('public',)
        IGNORED = ['/admin', '/back-office', '/other-pages']
        ALTER_PRIORITY = 0.1
        LOGGER = logging.getLogger('sitemap')

    sitemap = Sitemap(app, 'https://myshop.org', config_obj=Config)
    sitemap.add_rule('/goods', Product, slug='id', lastmod='updated')
    app.add_url_rule('/sitemap.xml', endpoint='sitemap', view_func=sitemap.view)

Moreover you can get a static file by using:
    sitemap.build_static()
"""
from collections import namedtuple
from datetime import datetime
from os.path import abspath, join, exists
from re import split
from xml.etree import ElementTree as ET

from flask import render_template, make_response


# todo: lastmod неизменённых
# todo: проблема с :path

__all__ = ('SitemapConfig', 'FlaskSitemap')

Record = namedtuple('Record', 'loc lastmod priority')


class SitemapConfig:
    """A class to set configurations

    FOLDER - NOT NEED FOR DYNAMIC SITEMAP, dynamic one will be created in app/templates and rendered from there;
             a tuple of folders to make path where to put a STATIC sitemap.xml,
    IGNORED - a list of strings which ignored URIs contain
    INDEX_PRIORITY - float, a priority of the index page
    CONTENT_PRIORITY - float, a priority of pages generated by models
    ALTER_PRIORITY - float, a priority of other pages
    LOGGER - an instance of logging.Logger, creates child of app.logger if not set
    """

    FOLDER = ('..', )
    IGNORED = ['/admin', '/static', ]
    INDEX_PRIORITY = CONTENT_PRIORITY = ALTER_PRIORITY = None
    LOGGER = None

    def from_object(self, obj):
        """Updates the values from the given object
        :param obj: a class with the same attributes as this one
        """
        if obj:
            for key in dir(obj):
                if key.isupper():
                    self[key] = getattr(obj, key)

        return self

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, item):
        return self.__dict__.get(item)

    def __repr__(self):
        return '<Sitemap configurations object>'


class SitemapMeta:

    def __init__(self, *args, **kwargs):
        pass


class FlaskSitemap(SitemapMeta):
    """A sitemap generator"""

    attrs = {
        'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance",
        'xmlns': "http://www.sitemaps.org/schemas/sitemap/0.9",
        'xsi:schemaLocation':
            "http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd"
    }

    def __init__(self, app, base_url: str, config_obj=None, *args, **kwargs):
        """Creates an instance of a Sitemap

        :param app: an instance of Flask application
        :param base_url: your base URL such as 'http://site/com'
        :param config_obj: a class with configurations
        """
        super().__init__(*args, **kwargs)
        assert app.extensions.get('sqlalchemy'), 'Flask-SQLAlchemy not found'

        self.config = SitemapConfig().from_object(config_obj)
        self.app = app
        self.url = base_url
        self.start = datetime.now().strftime('%Y-%m-%dT%H:%M:%S')
        self.rules = [rule_obj.rule for rule_obj in app.url_map.iter_rules() if 'GET' in rule_obj.methods]
        self.rules.sort(key=len)
        self.rules = iter(self.rules)
        self.log = app.logger.getChild('sitemap') if not self.config.LOGGER else self.config.LOGGER

        # containers
        self.data = []
        self.models = {}

        self._create_template()
        self.log.info('Sitemap has been initialized')

    def _create_template(self):
        """Creates a template xml file in app templates directory"""
        root = abspath(self.app.__module__).rsplit('/', 1)[0]
        template_folder = self.app.template_folder
        filename = ''.join((root, '/', template_folder, '/sitemap.xml'))
        tree = r"""<?xml version='1.0' encoding='UTF-8'?>
            <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" 
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                    xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 
                    http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd">
                {% for record in data %}
                    <url>
                        <loc>{{ record.loc }}</loc>
                        {% if record.lastmod %}
                            <lastmod>{{ record.lastmod }}</lastmod>
                        {% endif %}
                        {% if record.priority %}
                            <priority>{{ record.priority }}</priority>
                        {% endif %}
                    </url>
                {% endfor %}
            </urlset>
        """

        if not exists(filename):
            with open(filename, 'w') as file:
                file.write(tree)

    def _exclude(self) -> list:
        """Excludes URIs in IGNORED from self.rules"""
        public_uris = self.rules

        for item in self.config.IGNORED:
            public_uris = iter([uri for uri in public_uris if item not in uri])

        return public_uris

    def _prepare_data(self):
        """Prepares data to be used by builder"""
        self.data.clear()
        self.data.append(Record(self.url, self.start, self.config.INDEX_PRIORITY))
        uris = self._exclude()

        for uri in uris:
            self.log.debug(f'Preparing links for {uri}')
            splitted = split(r'/<[\w:]+>', uri, maxsplit=1)

            if len(splitted) > 1:
                replaced = self._replace_patterns(uri, splitted)
                self.data.extend(replaced)
            else:
                self.data.append(Record(self.url + uri, self.start, self.config.ALTER_PRIORITY))

    def _replace_patterns(self, uri, splitted) -> list:
        """Replaces '/<slug>/...' with real URIs

        :param uri: a relative URL without base
        :param splitted: a list with parts of URI
        :returns a list of Records
        """

        prefix, end = splitted[0], splitted[-1]
        prefix = '/' if not prefix else prefix

        assert self.models.get(prefix), f'Your should add {uri} to ignored or add a new rule'

        model, slug, updated, priority = self.models.get(prefix)
        prepared = []

        try:
            for record in model.query.all():
                if slug:
                    uri = getattr(record, slug)
                    loc = f'{self.url}{prefix}/{uri}{end}'
                else:
                    loc = f'{self.url}{prefix}{end}'

                if updated:
                    lastmod = getattr(record, updated)
                    if isinstance(lastmod, datetime):
                        lastmod = lastmod.strftime('%Y-%m-%dT%H:%M:%S')
                else:
                    lastmod = None

                prepared.append(Record(loc, lastmod, priority))
        except AttributeError:
            self.log.warning(f'{model} has no attributes: {slug} and/or {updated}')

        return prepared

    def add_rule(self, path: str, model, slug='slug', lastmod: str=None, priority: float=None):
        """Adds a rule to the builder to generate urls by a template using models of an app

        :param path: a part of URI is used to get a page generated through a model
        :param model: a model of an app that has a slug, e.g. an instance of SQLAlchemy.Model
        :param slug: a slug attribute of this model
        :param lastmod: an attribute of this model which is instance of the datetime object
        :param priority: a priority of URL to be set
        """
        priority = priority or self.config.CONTENT_PRIORITY

        if priority:
            assert 0.0 < priority <= 1.0, 'Priority should be a float between 0.0 and 1.0'

        self.models.update({path: (model, slug, lastmod, priority)})

    def build_static(self, filename='sitemap.xml'):
        """Builds an XML file. The system user of the app should have rights to write files

        :param filename: the name of target file (without path)
        """
        self._prepare_data()

        fullname = join(*self.config.FOLDER, filename) if self.config.FOLDER else filename
        self.log.info(f'Creating {fullname}...')

        url_set = ET.Element('urlset', self.attrs)
        sub = ET.SubElement

        for record in self.data:
            url = sub(url_set, "url")
            sub(url, "loc").text = record.loc

            if record.lastmod:
                sub(url, "lastmod").text = record.lastmod

            if record.priority:
                sub(url, "priority").text = str(record.priority)

        tree = ET.ElementTree(url_set)
        tree.write(fullname, xml_declaration=True, encoding='UTF-8')
        self.log.info('Static sitemap is ready.')

    def view(self):
        self._prepare_data()
        template = render_template('sitemap.xml', data=self.data)
        response = make_response(template)
        response.headers['Content-Type'] = 'application/xml'
        return response

    def __repr__(self):
        return f'<Sitemap object of {self.url} based on {self.app} >'


def test():
    pass


if __name__ == '__main__':
    test()
